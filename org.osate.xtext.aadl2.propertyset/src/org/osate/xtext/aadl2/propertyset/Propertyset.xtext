// automatically generated by Xtext
grammar org.osate.xtext.aadl2.propertyset.Propertyset with org.osate.xtext.aadl2.properties.Properties

import "platform:/resource/org.osate.aadl2/model/aadl2.ecore" as aadl2

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Properties

PropertySet returns aadl2::PropertySet:
	'property' 'set' name=ID 'is'
	('with' (importedUnit+=[aadl2::PropertySet|ID])  
	    (',' importedUnit+=[aadl2::PropertySet|ID])* ';')*
	(ownedPropertyType+=PropertyType | ownedProperty+=PropertyDefinition 
	| ownedPropertyConstant+=PropertyConstant)*
	'end' ID ';' ;

PropertyType returns aadl2::PropertyType:
	(BooleanType|StringType|EnumerationType|UnitsType |RealType
	|IntegerType|RangeType|ClassifierType|ReferenceType|RecordType) 
	';';

UnnamedPropertyType returns aadl2::PropertyType:
	(ListType|
		UnnamedBooleanType|UnnamedStringType|UnnamedEnumerationType|UnnamedUnitsType |UnnamedRealType
	|UnnamedIntegerType|UnnamedRangeType|UnnamedClassifierType|UnnamedReferenceType|UnnamedRecordType) 
	;


BooleanType returns aadl2::AadlBoolean:
	 name=ID ':' 'type' 
	'aadlboolean';


UnnamedBooleanType returns aadl2::AadlBoolean:
	{aadl2::AadlBoolean}'aadlboolean';

StringType returns aadl2::AadlString:
	name=ID ':' 'type' 
	'aadlstring';

UnnamedStringType returns aadl2::AadlString:
	{aadl2::AadlString}'aadlstring';

EnumerationType returns aadl2::EnumerationType:
	name=ID ':' 'type' 
	'enumeration'
	'(' ownedLiteral+=EnumerationLiteral (',' ownedLiteral+=EnumerationLiteral)* ')';

UnnamedEnumerationType returns aadl2::EnumerationType:
	'enumeration'
	'(' ownedLiteral+=EnumerationLiteral (',' ownedLiteral+=EnumerationLiteral)* ')';

EnumerationLiteral returns aadl2::EnumerationLiteral:
	name=ID;

UnitsType returns aadl2::UnitsType:
	name=ID ':' 'type' 
	'units'
	'(' ownedLiteral+=UnitLiteral (',' ownedLiteral+=UnitLiteralConversion)* ')';

UnnamedUnitsType returns aadl2::UnitsType:
	'units'
	'(' ownedLiteral+=UnitLiteral (',' ownedLiteral+=UnitLiteralConversion)* ')';

UnitLiteral returns aadl2::UnitLiteral:
	name=ID;

UnitLiteralConversion returns aadl2::UnitLiteral:
	name=ID '=>' baseUnit=[aadl2::UnitLiteral|ID] STAR factor=NumberValue
	;

RealType returns aadl2::AadlReal:
	name=ID ':' 'type' 
	'aadlreal' (range=RealRange)? ( (ownedUnitsType=UnnamedUnitsType| ('units' unitsType=[aadl2::UnitsType|QPREF])))?
	 ;

UnnamedRealType returns aadl2::AadlReal:
	{aadl2::AadlReal}
	'aadlreal' (range=RealRange)? ((ownedUnitsType=UnnamedUnitsType| ('units' unitsType=[aadl2::UnitsType|QPREF])))?
	 ;

IntegerType returns aadl2::AadlInteger:
	name=ID ':' 'type' 
	'aadlinteger' (range=IntegerRange)? ((ownedUnitsType=UnnamedUnitsType| ('units' unitsType=[aadl2::UnitsType|QPREF])))?
	 ;

UnnamedIntegerType returns aadl2::AadlInteger:
	{aadl2::AadlInteger}
	'aadlinteger' (range=IntegerRange)? ( (ownedUnitsType=UnnamedUnitsType| ('units' unitsType=[aadl2::UnitsType|QPREF])))?
	 ;

RangeType returns aadl2::RangeType:
	name=ID ':' 'type' 
	'range' 'of' (ownedNumberType=(UnnamedIntegerType|UnnamedRealType)
		| numberType=[aadl2::NumberType|QPREF]
	)
	 ;

UnnamedRangeType returns aadl2::RangeType:
	{aadl2::RangeType}
	'range' 'of' (ownedNumberType=(UnnamedIntegerType|UnnamedRealType)
		| numberType=[aadl2::NumberType|QPREF]
	)
	 ;

ClassifierType returns aadl2::ClassifierType:
	name=ID ':' 'type' 
	'classifier' 
	('(' classifierReference+=QMReference (',' classifierReference+=QMReference)*')')?
	 ;

UnnamedClassifierType returns aadl2::ClassifierType:
	{aadl2::ClassifierType}
	'classifier' 
	('(' classifierReference+=QMReference (',' classifierReference+=QMReference)*')')?
	 ;

QMReference returns aadl2::MetaclassReference:
	('{'  annexName=ID '}' STAR STAR )?
	( metaclassName+=(CoreKeyWord|ID) )+
	 ;

QCReference returns aadl2::ClassifierValue:
   classifier=[aadl2::ComponentClassifier|FQCREF]
  ;

ReferenceType returns aadl2::ReferenceType:
	name=ID ':' 'type' 
	'reference' 
	('(' namedElementReference+=QMReference (',' namedElementReference+=QMReference)* ')')?
	 ;

UnnamedReferenceType returns aadl2::ReferenceType:
	'reference' {aadl2::ReferenceType}
	('(' namedElementReference+=QMReference (',' namedElementReference+=QMReference)* ')')?
	 ;

RecordType returns aadl2::RecordType:
	name=ID ':' 'type' 
	'record' '('
	(ownedField+=RecordField )+
	')'
	 ;

UnnamedRecordType returns aadl2::RecordType:
	'record' '('
	(ownedField+=RecordField )+
	')'
	 ;

RecordField returns aadl2::BasicProperty:
	name=ID ':'
//	('list' 'of')* is handled as part of UnnamedPropertytype
	(propertyType=[aadl2::PropertyType|QPREF]|ownedPropertyType=UnnamedPropertyType)
	';'
	 ;

//&&&&& Property Definition


PropertyDefinition returns aadl2::Property:
	name=ID ':'
	(inherit?='inherit')?
//	('list' 'of')* is handled as part of UnnamedPropertytype
	(propertyType=[aadl2::PropertyType|QPREF]|ownedPropertyType=UnnamedPropertyType)
	('=>' defaultValue=PropertyExpression)?
	'applies' 'to' '('
	((appliesTo+=PropertyOwner (',' appliesTo+=PropertyOwner)*)|
	appliesTo+=AllReference)
	')'
	';'
	 ;

AllReference returns aadl2::MetaclassReference:
	 metaclassName+='all'  // &&&&& actually set it to NamedElement using ALL rule returning "named element" as string
;

ListType returns aadl2::ListType:
	 'list' 'of'  
	(elementType=[aadl2::PropertyType|QPREF]|ownedElementType=UnnamedPropertyType)
;


PropertyOwner returns aadl2::PropertyOwner:
	// classifier value is always qualified by a package name
	QMReference | QCReference
	 ;



PropertyConstant returns aadl2::PropertyConstant:
	name=ID ':' 'constant'
//	('list' 'of')* is handled as part of UnnamedPropertytype
	(propertyType=[aadl2::PropertyType|QPREF]|ownedPropertyType=UnnamedPropertyType)
	'=>' constantValue=ConstantPropertyExpression  
	';'
	 ;




NumberValue returns aadl2::NumberValue:
	RealLit | IntegerLit ;

RealLit returns aadl2::RealLiteral:
	value=SignedReal ;


IntegerLit returns aadl2::IntegerLiteral:
	value=SignedInt ;

ConstantPropertyExpression returns aadl2::PropertyExpression:
	 RecordTerm |NumericRangeTerm
	| ComputedTerm | StringTerm 
	| RealTerm | IntegerTerm 
	 | ComponentClassifierTerm 	| ListTerm 
	  | LiteralorReferenceTerm
	 |BooleanLiteral
	;


IntegerRange returns aadl2::NumericRange:
	lowerBound=(IntegerTerm | SignedConstant | ConstantValue )
	'..' upperBound=(IntegerTerm | SignedConstant | ConstantValue )
	;

RealRange returns aadl2::NumericRange:
	lowerBound=(RealTerm | SignedConstant | ConstantValue )
	'..' upperBound=(RealTerm | SignedConstant | ConstantValue )
	;



CoreKeyWord :
	'system' | 'thread' | 'group' | 'process' | 'data' | 'processor' | 'memory' | 'device' | 'bus' 
	 | 'virtual' | 'subprogram' | 'feature' |'package'|'parameter'
	| 'port' |'calls' |'event'|'flow'|'implementation'|'type'|'mode'|'prototype'|'to' |'end'
	| 'abstract' |'access'|'classifier'
	// the next ones are filtered as they could be used in an annex
//	 |'reference' | 'connections' |'constant'|'delta'
//	| 'and' | 'all' | 'annex' | 'applies' |'binding'|'boolean'|'enumeration'|'path'|'private'
//	|'extends'|'false'|'features'|'flows'|'in'|'inherit'|'initial'|'integer'|'inverse'|'is'|'list'|'modes'|'none'
//	|'not'
	// more to come if we have annex parsers 
;



// fully qualified classifier name (always includes package name
FQCREF:
	(ID '::')+ ID ('.' ID)?;
